{"version":3,"sources":["../dist-tsc/schemaFunctions.js"],"names":["Object","defineProperty","exports","value","ethABI","require","types_1","failWith","msg","Error","encodeCall","abi","parameters","inputTypes","inputs","map","i","type","Buffer","concat","methodID","name","rawEncode","toString","generateDefaultValue","FunctionInputKind","Owner","encodeSell","schema","asset","address","transfer","getTransferFunction","target","calldata","encodeDefaultCall","replacementPattern","encodeReplacementPattern","encodeBuy","replaceables","filter","kind","Replaceable","length","input","Asset","allowReplaceBit","doNotAllowReplaceBit","maskArr","elementaryName","encoded","encodeSingle","push","repeat","mask","reduce","x","y","ret","byteChars","substr","padEnd","byte","mul","buf","alloc","writeUInt8","slice","functions","transferFrom"],"mappings":"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","file":"schemaFunctions.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethABI = require(\"ethereumjs-abi\");\nconst types_1 = require(\"./types\");\nconst failWith = (msg) => {\n    throw new Error(msg);\n};\nexports.encodeCall = (abi, parameters) => {\n    const inputTypes = abi.inputs.map(i => i.type);\n    return '0x' + Buffer.concat([\n        ethABI.methodID(abi.name, inputTypes),\n        ethABI.rawEncode(inputTypes, parameters),\n    ]).toString('hex');\n};\nconst generateDefaultValue = (type) => {\n    switch (type) {\n        case 'address':\n        case types_1.FunctionInputKind.Owner:\n            /* Null address is sometimes checked in transfer calls. */\n            return '0x1111111111111111111111111111111111111111';\n        case 'bytes32':\n            return '0x0000000000000000000000000000000000000000000000000000000000000000';\n        case 'bool':\n            return false;\n        case 'int':\n        case 'uint':\n        case 'uint8':\n        case 'uint16':\n        case 'uint32':\n        case 'uint64':\n        case 'uint256':\n            return 0;\n        default:\n            failWith('Default value not yet implemented for type: ' + type);\n    }\n};\nexports.encodeSell = (schema, asset, address) => {\n    const transfer = getTransferFunction(schema)(asset);\n    return {\n        target: transfer.target,\n        calldata: exports.encodeDefaultCall(transfer, address),\n        replacementPattern: exports.encodeReplacementPattern(transfer),\n    };\n};\nexports.encodeBuy = (schema, asset, address) => {\n    const transfer = getTransferFunction(schema)(asset);\n    const replaceables = transfer.inputs.filter((i) => i.kind === types_1.FunctionInputKind.Replaceable);\n    if (replaceables.length !== 1) {\n        failWith('Only 1 input can match transfer destination, but instead ' + replaceables.length + ' did');\n    }\n    const inputs = transfer.inputs.map((i) => {\n        if (i.kind === types_1.FunctionInputKind.Replaceable) {\n            return address;\n        }\n        else if (i.value == null) {\n            return generateDefaultValue(i.kind).toString();\n        }\n        else {\n            return i.value.toString();\n        }\n    });\n    const calldata = exports.encodeCall(transfer, inputs);\n    return {\n        target: transfer.target,\n        calldata,\n        replacementPattern: '0x',\n    };\n};\nexports.encodeDefaultCall = (abi, address) => {\n    const parameters = abi.inputs.map(input => {\n        switch (input.kind) {\n            case types_1.FunctionInputKind.Asset:\n                return input.value;\n            case types_1.FunctionInputKind.Replaceable:\n                return generateDefaultValue(input.type);\n            case types_1.FunctionInputKind.Owner:\n                return address;\n        }\n    });\n    return exports.encodeCall(abi, parameters);\n};\nexports.encodeReplacementPattern = abi => {\n    const allowReplaceBit = '1';\n    const doNotAllowReplaceBit = '0';\n    /* Four bytes for method ID. */\n    const maskArr = [doNotAllowReplaceBit, doNotAllowReplaceBit,\n        doNotAllowReplaceBit, doNotAllowReplaceBit];\n    /* This DOES NOT currently support dynamic-length data (arrays). */\n    abi.inputs.map(i => {\n        const type = ethABI.elementaryName(i.type);\n        const encoded = ethABI.encodeSingle(type, generateDefaultValue(i.type));\n        if (i.kind === types_1.FunctionInputKind.Replaceable) {\n            maskArr.push(allowReplaceBit.repeat(encoded.length));\n        }\n        else {\n            maskArr.push(doNotAllowReplaceBit.repeat(encoded.length));\n        }\n    });\n    let mask = maskArr.reduce((x, y) => x + y, '');\n    const ret = [];\n    /* Encode into bytes. */\n    while (true) {\n        let byteChars = mask.substr(0, 8);\n        if (byteChars.length === 0) {\n            break;\n        }\n        byteChars = byteChars.padEnd(8, '0');\n        let byte = 0;\n        let mul = 2 ** 7;\n        for (let i = 0; i < 8; i++) {\n            byte += byteChars[i] === allowReplaceBit ? mul : 0;\n            mul = mul / 2;\n        }\n        const buf = Buffer.alloc(1);\n        buf.writeUInt8(byte, 0);\n        ret.push(buf);\n        mask = mask.slice(8);\n    }\n    return '0x' + Buffer.concat(ret).toString('hex');\n};\nfunction getTransferFunction(schema) {\n    return schema.functions.transferFrom\n        || schema.functions.transfer;\n}\n//# sourceMappingURL=schemaFunctions.js.map"]}