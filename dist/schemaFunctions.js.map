{"version":3,"sources":["../dist-tsc/schemaFunctions.js"],"names":["Object","defineProperty","exports","value","ethABI","require","types_1","failWith","msg","Error","encodeCall","abi","parameters","inputTypes","inputs","map","i","type","Buffer","concat","methodID","name","rawEncode","toString","generateDefaultValue","encodeSell","schema","asset","transfer","functions","target","calldata","encodeDefaultCall","replacementPattern","encodeReplacementPattern","encodeBuy","address","matching","filter","kind","FunctionInputKind","Replaceable","length","input","Asset","allowReplaceBit","doNotAllowReplaceBit","maskArr","elementaryName","encoded","encodeSingle","push","repeat","mask","reduce","x","y","ret","byteChars","substr","padEnd","byte","mul","buf","alloc","writeUInt8","slice"],"mappings":"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","file":"schemaFunctions.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethABI = require(\"ethereumjs-abi\");\nconst types_1 = require(\"./types\");\nconst failWith = (msg) => {\n    throw new Error(msg);\n};\nexports.encodeCall = (abi, parameters) => {\n    const inputTypes = abi.inputs.map(i => i.type);\n    return '0x' + Buffer.concat([\n        ethABI.methodID(abi.name, inputTypes),\n        ethABI.rawEncode(inputTypes, parameters),\n    ]).toString('hex');\n};\nconst generateDefaultValue = (type) => {\n    switch (type) {\n        case 'address':\n            /* Null address is sometimes checked in transfer calls. */\n            return '0x1111111111111111111111111111111111111111';\n        case 'bytes32':\n            return '0x0000000000000000000000000000000000000000000000000000000000000000';\n        case 'bool':\n            return false;\n        case 'int':\n        case 'uint':\n        case 'uint8':\n        case 'uint16':\n        case 'uint32':\n        case 'uint64':\n        case 'uint256':\n            return 0;\n        default:\n            failWith('Default value not yet implemented for type: ' + type);\n    }\n};\nexports.encodeSell = (schema, asset) => {\n    const transfer = schema.functions.transfer(asset);\n    return {\n        target: transfer.target,\n        calldata: exports.encodeDefaultCall(transfer),\n        replacementPattern: exports.encodeReplacementPattern(transfer),\n    };\n};\nexports.encodeBuy = (schema, asset, address) => {\n    const transfer = schema.functions.transfer(asset);\n    const matching = transfer.inputs.filter(i => i.kind === types_1.FunctionInputKind.Replaceable);\n    if (matching.length !== 1) {\n        failWith('Only 1 input can match transfer destination, but instead ' + matching.length + ' did');\n    }\n    matching[0].value = address;\n    const calldata = exports.encodeCall(transfer, transfer.inputs.map(i => i.value.toString()));\n    return {\n        target: transfer.target,\n        calldata,\n        replacementPattern: '0x',\n    };\n};\nexports.encodeDefaultCall = abi => {\n    const parameters = abi.inputs.map(input => {\n        switch (input.kind) {\n            case types_1.FunctionInputKind.Asset:\n                return input.value;\n            case types_1.FunctionInputKind.Replaceable:\n                return generateDefaultValue(input.type);\n        }\n    });\n    return exports.encodeCall(abi, parameters);\n};\nexports.encodeReplacementPattern = abi => {\n    const allowReplaceBit = '1';\n    const doNotAllowReplaceBit = '0';\n    /* Four bytes for method ID. */\n    const maskArr = [doNotAllowReplaceBit, doNotAllowReplaceBit,\n        doNotAllowReplaceBit, doNotAllowReplaceBit];\n    /* This DOES NOT currently support dynamic-length data (arrays). */\n    abi.inputs.map(i => {\n        const type = ethABI.elementaryName(i.type);\n        const encoded = ethABI.encodeSingle(type, generateDefaultValue(i.type));\n        if (i.kind === types_1.FunctionInputKind.Replaceable) {\n            maskArr.push(allowReplaceBit.repeat(encoded.length));\n        }\n        else {\n            maskArr.push(doNotAllowReplaceBit.repeat(encoded.length));\n        }\n    });\n    let mask = maskArr.reduce((x, y) => x + y, '');\n    const ret = [];\n    /* Encode into bytes. */\n    while (true) {\n        let byteChars = mask.substr(0, 8);\n        if (byteChars.length === 0) {\n            break;\n        }\n        byteChars = byteChars.padEnd(8, '0');\n        let byte = 0;\n        let mul = 2 ** 7;\n        for (let i = 0; i < 8; i++) {\n            byte += byteChars[i] === allowReplaceBit ? mul : 0;\n            mul = mul / 2;\n        }\n        const buf = Buffer.alloc(1);\n        buf.writeUInt8(byte, 0);\n        ret.push(buf);\n        mask = mask.slice(8);\n    }\n    return '0x' + Buffer.concat(ret).toString('hex');\n};\n//# sourceMappingURL=schemaFunctions.js.map"]}